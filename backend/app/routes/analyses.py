from fastapi import APIRouter, HTTPException, status, Body, Depends
from fastapi.encoders import jsonable_encoder
from typing import List, Optional
from bson import ObjectId
from datetime import datetime

from app.database.connection import get_database
from app.models.analysis import Analysis, AnalysisCreate, AnalysisResult

router = APIRouter(
    prefix="/analyses",
    tags=["analyses"],
    responses={404: {"description": "Not found"}},
)

@router.post("/", response_model=Analysis, status_code=status.HTTP_202_ACCEPTED)
async def create_analysis(analysis_request: AnalysisCreate = Body(...)):
    """
    Create a new analysis request.
    This is a placeholder endpoint that returns a mock response.
    In a real implementation, this would trigger an asynchronous task to analyze SEC filings.
    """
    db = get_database()
    
    # Check if the company exists
    if not ObjectId.is_valid(analysis_request.company_id):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid company ID format: {analysis_request.company_id}"
        )
    
    company = await db.companies.find_one({"_id": ObjectId(analysis_request.company_id)})
    if company is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Company with ID {analysis_request.company_id} not found"
        )
    
    # Create a mock analysis result
    mock_result = AnalysisResult(
        stock_expected_to_go_up=True,
        expected_by_date=datetime.now().date(),
        is_good_buy=True,
        reasoning="This is a mock analysis result. In a real implementation, this would be generated by analyzing SEC filings using an LLM."
    )
    
    # Create the analysis document
    analysis_dict = {
        "company_id": ObjectId(analysis_request.company_id),
        "analysis_date": datetime.utcnow(),
        "filings_analyzed": analysis_request.filings_analyzed or ["8-K", "10-K", "10-Q"],
        "analysis_result": jsonable_encoder(mock_result)
    }
    
    # Insert the analysis into the database
    result = await db.analyses.insert_one(analysis_dict)
    
    # Get the created analysis
    created_analysis = await db.analyses.find_one({"_id": result.inserted_id})
    
    return created_analysis

@router.get("/{analysis_id}", response_model=Analysis)
async def get_analysis(analysis_id: str):
    """
    Get a single analysis by ID.
    """
    db = get_database()
    
    # Check if the ID is a valid ObjectId
    if not ObjectId.is_valid(analysis_id):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid analysis ID format: {analysis_id}"
        )
    
    analysis = await db.analyses.find_one({"_id": ObjectId(analysis_id)})
    if analysis is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Analysis with ID {analysis_id} not found"
        )
    
    return analysis

@router.get("/company/{company_id}", response_model=List[Analysis])
async def get_analyses_by_company(company_id: str):
    """
    Get all analyses for a company.
    """
    db = get_database()
    
    # Check if the ID is a valid ObjectId
    if not ObjectId.is_valid(company_id):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid company ID format: {company_id}"
        )
    
    # Check if the company exists
    company = await db.companies.find_one({"_id": ObjectId(company_id)})
    if company is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Company with ID {company_id} not found"
        )
    
    # Get all analyses for the company
    analyses = await db.analyses.find({"company_id": ObjectId(company_id)}).to_list(1000)
    
    return analyses 